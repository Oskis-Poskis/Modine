#version 430

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
};

struct Triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
    vec3 normal;
    vec3 color;
};

struct Camera {
    vec3 direction;
    vec3 position;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

uniform Camera camera;

// input/output
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(rgba32f, binding = 10) readonly uniform image2D triangleTextureData;

Triangle unpackTriangle(int index);

bool triangleIntersect1(Ray ray, Triangle triangle);
bool triangleIntersect2(Ray ray, Triangle triangle);

void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(img_output);
    float horizontalCoefficient = ((float(pixel_coords.x) * 2 - screen_size.x) / screen_size.y);
    float verticalCoefficient = ((float(pixel_coords.y) * 2 - screen_size.y) / screen_size.y); 

    vec3 pixel = vec3(0.0);

    vec3 forward = normalize(camera.direction);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = cross(right, forward);

    Ray ray;
    ray.origin = camera.position;
    ray.direction = camera.direction + horizontalCoefficient * right + verticalCoefficient * up;

    for (int i = 0; i < 3; i++)
    {
        pixel += triangleIntersect1(ray, unpackTriangle(i)) ? vec3(1) : vec3(0);
    }

    imageStore(img_output, pixel_coords, vec4(pixel, 1.0));
}

bool triangleIntersect1(Ray ray, Triangle triangle)
{
    vec3 edge1 = triangle.v1 - triangle.v0;
    vec3 edge2 = triangle.v2 - triangle.v0;
    vec3 pvec = cross(ray.direction, edge2);
    float det = dot(edge1, pvec);

    if (det != 0.0)
    {
        float inv_det = 1.0 / det;
        vec3 tvec = ray.origin - triangle.v0;
        float u = dot(tvec, pvec) * inv_det;

        if (u >= 0.0 && u <= 1.0)
        {
            vec3 qvec = cross(tvec, edge1);
            float v = dot(ray.direction, qvec) * inv_det;

            if (v >= 0.0 && u + v <= 1.0) {
                float t = dot(edge2, qvec) * inv_det;
                return true;
            }

            else return false;
        }

        else return false;
    }
    
    else return false;
}

bool triangleIntersect2(Ray ray, Triangle triangle)
{
    const float EPSILON = 0.000001;
    vec3 vertex0 = triangle.v0;
    vec3 vertex1 = triangle.v1;
    vec3 vertex2 = triangle.v2;
    vec3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(ray.direction, edge2);
    a = dot(edge1, h);
    if (a > -EPSILON && a < EPSILON) return false;
    f = 1 / a;
    s = ray.origin - vertex0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1) return false;
    q = cross(s, edge1);
    v = f * dot(ray.direction, q);
    if (v < 0.0 || u + v > 1) return false;
    float t = f * dot(edge2, q);
    if (t > EPSILON) return true;
    else return false;
}

Triangle unpackTriangle(int index)
{
    Triangle triangle;
    
    vec3 attributeChunk = imageLoad(triangleTextureData, ivec2(0, index)).rgb;
    triangle.v0 = attributeChunk;
    
    attributeChunk = imageLoad(triangleTextureData, ivec2(1, index)).rgb;
    triangle.v1 = attributeChunk;
    
    attributeChunk = imageLoad(triangleTextureData, ivec2(2, index)).rgb;
    triangle.v2 = attributeChunk;

    triangle.normal = normalize(cross(triangle.v1 - triangle.v0, triangle.v2 - triangle.v0));
    triangle.color = vec3(1);

    return triangle;
}