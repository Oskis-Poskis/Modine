#version 430

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
};

struct Triangle {
    vec3 v0;
    float pad0;
    vec3 v1;
    float pad1;
    vec3 v2;
    float pad2;
    vec3 normal0;
    float pad3;
    vec3 normal1;
    float pad4;
    vec3 normal2;
    float pad5;
};

struct Camera {
    vec3 direction;
    vec3 position;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

uniform vec3 ambient;
uniform Camera camera;

// input/output
layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(std430, binding = 0) readonly buffer TriangleSSBO
{
    Triangle Triangles[];
} triangleSSBO;

//bool intersect_triangle(Ray r, Triangle triangle, out float t, out vec3 barycentric_coordinates);
bool intersect_triangle(Ray r, Triangle triangle, out float t, out vec3 barycentric_coordinates);
vec3 shade_triangles(Ray ray);

void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(img_output);
    float horizontalCoefficient = ((float(pixel_coords.x) * 2 - screen_size.x) / screen_size.y);
    float verticalCoefficient = ((float(pixel_coords.y) * 2 - screen_size.y) / screen_size.y); 

    vec3 pixel = ambient;

    vec3 forward = normalize(camera.direction);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = cross(right, forward);

    Ray ray;
    ray.origin = camera.position;
    ray.direction = camera.direction + horizontalCoefficient * right + verticalCoefficient * up;

    pixel = shade_triangles(ray);
    imageStore(img_output, pixel_coords, vec4(pixel, 1.0));
}

vec3 shade_triangles(Ray ray)
{
    float closestDistance = 1e10;
    int closestIndex = -1;
    bool didhit = false;
    vec3 barycentric = vec3(0);

    for (int i = 0; i < triangleSSBO.Triangles.length(); i++)
    {
        float t;

        Triangle tri = triangleSSBO.Triangles[i];
        if (intersect_triangle(ray, tri, t, barycentric))
        {
            vec3 intersection_point = ray.origin + t * ray.direction;
            float d = distance(intersection_point, ray.origin);
            if (d < closestDistance)
            {
                closestDistance = d;
                closestIndex = i;
            }

            didhit = true;
        }
    }

    if (didhit)
    {
        Triangle closestTriangle = triangleSSBO.Triangles[closestIndex];
        vec3 normal = barycentric.x * closestTriangle.normal0 + barycentric.y * closestTriangle.normal1 + barycentric.z * closestTriangle.normal2;
        float diffuse = max(0.0, dot(normal, vec3(1.0)));
        return vec3(diffuse) + ambient;
    }
}

bool intersect_triangle(Ray r, Triangle triangle, out float t, out vec3 barycentric_coordinates)
{
    vec3 E1 = triangle.v1 - triangle.v0;
    vec3 E2 = triangle.v2 - triangle.v0;
    vec3 P = cross(r.direction, E2);
    float det = dot(P, E1);
    if(det < 1e-6) return false;

    float invdet = 1.0 / det;
    vec3 T = r.origin - triangle.v0;
    float u = invdet * dot(P, T);
    if(u < 0.0 || u > 1.0) return false;

    vec3 Q = cross(T, E1);
    float v = invdet * dot(Q, r.direction);
    if(v < 0.0 || (u + v) > 1.0) return false;
    t = invdet * dot(Q, E2);

    barycentric_coordinates = vec3(1 - u - v, u, v);

    return t > 0.0;
}

bool intersect_triangle2(Ray ray, vec3 v0, vec3 v1, vec3 v2, out vec3 bary, out float t)
{
    vec3 v1v0 = v1 - v0;
    vec3 v2v0 = v2 - v0;
    vec3 rov0 = ray.origin - v0;
    vec3 normal = cross(v1v0, v2v0);
    vec3 q = cross(rov0, ray.direction);

    float x = dot(ray.direction, normal);
    bary.xy = vec2(dot(-q, v2v0), dot(q, v1v0)) / x;
    bary.z = 1.0 - bary.x - bary.y;

    t = dot(-normal, rov0) / x;

    return all(greaterThanEqual(vec4(bary, t), vec4(0.0)));
}